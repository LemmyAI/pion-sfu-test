<!DOCTYPE html>
<html>
<head>
    <title>Pion SFU Test</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background: #1a1a2e; color: #eee; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        #videos { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; }
        video { width: 300px; height: 225px; background: #000; border-radius: 8px; }
        .controls { margin: 20px 0; }
        #status { margin: 20px 0; padding: 10px; background: #16213e; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>ðŸŽ¥ Pion SFU Test</h1>
    
    <div id="status">Disconnected</div>
    
    <div class="controls">
        <button onclick="connect()">Connect</button>
        <button onclick="publish()">Publish Camera</button>
        <button onclick="subscribe()">Subscribe</button>
    </div>
    
    <div id="videos"></div>

    <script>
        let ws = null;
        let myId = null;
        let publisher = null;
        let subscriber = null;

        async function connect() {
            if (ws) return;
            ws = new WebSocket(`wss://${location.host}/sfu/ws`);
            
            ws.onmessage = async (e) => {
                const data = JSON.parse(e.data);
                console.log('ðŸ“© Received:', data.type);
                switch (data.type) {
                    case 'welcome':
                        myId = data.id;
                        document.getElementById('status').textContent = `Connected as ${myId}`;
                        break;
                    case 'publish_answer':
                        if (publisher) {
                            console.log('ðŸ“ Setting publish answer...');
                            await publisher.setRemoteDescription({ type: 'answer', sdp: data.sdp });
                            console.log('âœ… Publisher connected');
                        }
                        break;
                    case 'subscribe_offer':
                        if (subscriber) {
                            console.log('ðŸ“ Setting subscribe offer...');
                            await subscriber.setRemoteDescription({ type: 'offer', sdp: data.sdp });
                            const answer = await subscriber.createAnswer();
                            await subscriber.setLocalDescription(answer);
                            ws.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
                            console.log('âœ… Subscriber answer sent');
                        }
                        break;
                }
            };
            ws.onclose = () => { document.getElementById('status').textContent = 'Disconnected'; ws = null; };
            console.log('ðŸ”Œ Connecting...');
        }

        async function publish() {
            if (!ws || ws.readyState !== WebSocket.OPEN) { alert('Connect first!'); return; }
            
            // STUN for public IP discovery, no TURN (will use host candidates on same network)
            publisher = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            publisher.oniceconnectionstatechange = () => console.log('ðŸ§Š PUB ICE:', publisher.iceConnectionState);
            publisher.onconnectionstatechange = () => console.log('ðŸ”— PUB State:', publisher.connectionState);

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
            const myVideo = document.createElement('video');
            myVideo.srcObject = stream;
            myVideo.muted = true;
            myVideo.autoplay = true;
            document.getElementById('videos').appendChild(myVideo);
            stream.getTracks().forEach(track => publisher.addTrack(track, stream));

            const offer = await publisher.createOffer();
            await publisher.setLocalDescription(offer);
            
            // Wait for ICE with timeout
            let iceDone = false;
            await new Promise(resolve => {
                const timeout = setTimeout(() => {
                    if (!iceDone) { iceDone = true; console.log('â±ï¸ ICE timeout, sending anyway'); resolve(); }
                }, 3000);
                
                publisher.onicecandidate = (e) => {
                    if (e.candidate) {
                        const type = e.candidate.candidate.includes('srflx') ? 'SRFLX' : 
                                     e.candidate.candidate.includes('host') ? 'HOST' : 'RELAY';
                        console.log('ðŸ§Š PUB ICE:', type, e.candidate.candidate.substring(0, 50));
                    } else {
                        clearTimeout(timeout);
                        iceDone = true;
                        console.log('ðŸ§Š PUB ICE complete');
                        resolve();
                    }
                };
                
                if (publisher.iceGatheringState === 'complete') {
                    clearTimeout(timeout);
                    iceDone = true;
                    resolve();
                }
            });

            ws.send(JSON.stringify({ type: 'publish', sdp: publisher.localDescription.sdp }));
            console.log('ðŸ“¤ Publisher offer sent');
        }

        async function subscribe() {
            if (!ws || ws.readyState !== WebSocket.OPEN) { alert('Connect first!'); return; }
            
            subscriber = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            subscriber.oniceconnectionstatechange = () => console.log('ðŸ§Š SUB ICE:', subscriber.iceConnectionState);
            subscriber.ontrack = (e) => {
                console.log('ðŸ“¹ Got track:', e.track.kind);
                const video = document.createElement('video');
                video.srcObject = e.streams[0];
                video.autoplay = true;
                document.getElementById('videos').appendChild(video);
            };

            ws.send(JSON.stringify({ type: 'subscribe' }));
            console.log('ðŸ“¤ Subscribe request sent');
        }
    </script>
</body>
</html>
