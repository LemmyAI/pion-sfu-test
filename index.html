<!DOCTYPE html>
<html>
<head>
    <title>Pion SFU Test (LAN)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background: #1a1a2e; color: #eee; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        #videos { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 20px; }
        video { width: 300px; height: 225px; background: #000; border-radius: 8px; }
        .controls { margin: 20px 0; }
        #status { margin: 20px 0; padding: 10px; background: #16213e; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>ðŸŽ¥ Pion SFU Test (LAN Only)</h1>
    
    <div id="status">Disconnected</div>
    
    <div class="controls">
        <button onclick="connect()">Connect</button>
        <button onclick="publish()">Publish Camera</button>
        <button onclick="subscribe()">Subscribe</button>
    </div>
    
    <div id="videos"></div>

    <script>
        let ws = null;
        let myId = null;
        let publisher = null;
        let subscriber = null;

        async function connect() {
            if (ws) return;
            ws = new WebSocket(`wss://${location.host}/sfu/ws`);
            
            ws.onmessage = async (e) => {
                const data = JSON.parse(e.data);
                console.log('ðŸ“© Received:', data.type);
                switch (data.type) {
                    case 'welcome':
                        myId = data.id;
                        document.getElementById('status').textContent = `Connected as ${myId}`;
                        break;
                    case 'publish_answer':
                        if (publisher) {
                            await publisher.setRemoteDescription({ type: 'answer', sdp: data.sdp });
                            console.log('âœ… Publisher connected');
                            document.getElementById('status').textContent += ' | âœ… Published';
                        }
                        break;
                    case 'subscribe_offer':
                        if (subscriber) {
                            await subscriber.setRemoteDescription({ type: 'offer', sdp: data.sdp });
                            const answer = await subscriber.createAnswer();
                            await subscriber.setLocalDescription(answer);
                            ws.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
                            console.log('âœ… Subscriber answer sent');
                        }
                        break;
                }
            };
            ws.onclose = () => { document.getElementById('status').textContent = 'Disconnected'; ws = null; };
            console.log('ðŸ”Œ Connecting...');
        }

        async function publish() {
            if (!ws || ws.readyState !== WebSocket.OPEN) { alert('Connect first!'); return; }
            
            // NO STUN/TURN - LAN only!
            publisher = new RTCPeerConnection({ iceServers: [] });
            
            publisher.oniceconnectionstatechange = () => console.log('ðŸ§Š ICE:', publisher.iceConnectionState);
            publisher.onconnectionstatechange = () => console.log('ðŸ”— State:', publisher.connectionState);

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
            const myVideo = document.createElement('video');
            myVideo.srcObject = stream;
            myVideo.muted = true;
            myVideo.autoplay = true;
            document.getElementById('videos').appendChild(myVideo);
            stream.getTracks().forEach(track => publisher.addTrack(track, stream));

            const offer = await publisher.createOffer();
            await publisher.setLocalDescription(offer);
            
            // Short timeout for LAN
            await new Promise(resolve => {
                if (publisher.iceGatheringState === 'complete') return resolve();
                const timeout = setTimeout(() => { console.log('â±ï¸ ICE timeout'); resolve(); }, 2000);
                publisher.onicegatheringstatechange = () => {
                    if (publisher.iceGatheringState === 'complete') { clearTimeout(timeout); resolve(); }
                };
                publisher.onicecandidate = (e) => {
                    if (e.candidate) console.log('ðŸ§Š ICE:', e.candidate.candidate.substring(0, 50));
                    else { clearTimeout(timeout); console.log('ðŸ§Š ICE done'); resolve(); }
                };
            });

            ws.send(JSON.stringify({ type: 'publish', sdp: publisher.localDescription.sdp }));
            console.log('ðŸ“¤ Offer sent');
        }

        async function subscribe() {
            if (!ws || ws.readyState !== WebSocket.OPEN) { alert('Connect first!'); return; }
            
            subscriber = new RTCPeerConnection({ iceServers: [] });
            subscriber.oniceconnectionstatechange = () => console.log('ðŸ§Š ICE:', subscriber.iceConnectionState);
            subscriber.ontrack = (e) => {
                console.log('ðŸ“¹ Got track:', e.track.kind);
                const video = document.createElement('video');
                video.srcObject = e.streams[0];
                video.autoplay = true;
                document.getElementById('videos').appendChild(video);
            };

            ws.send(JSON.stringify({ type: 'subscribe' }));
            console.log('ðŸ“¤ Subscribe request sent');
        }
    </script>
</body>
</html>
